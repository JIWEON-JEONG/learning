# Branch Strategy

## 배경 
어떤 기준점이 되는 Branch 에서 파생되는 Branch 를 만들건지, 이름은 어떻게 정할것인지 등에 대한 전략이 통일되지않으면  
소스코드가 꼬일 수 있게되어 효율적으로 관리하기 위해 전략들이 나오게 되었다.

> 예시  
> 팀원 A는 feature 브랜치를 main에서 생성, 팀원 B는 feature 브랜치를 develop에서 생성  
> 팀원 A는 feature 브랜치를 main에 병합, 팀원 B는 feature 브랜치를 develop에 병합

## Git Flow
- main or master: 제품 출시 버전을 관리하는 메인 브랜치

- develop: 다음 출시 버전을 위해 개발하는 브랜치

- feature: 새로운 기능을 개발하는 브랜치

- release: 다음 출시 버전을 준비하는 브랜치 (release 에서 발생하는 자잘한 버그들은 release 에서 고친 후 develop 에 merge)

- hotfix: 출시된 제품의 버그를 고치기 위한 브랜치

> pull 이 아닌 merge 를 통해 변경사항을 동기화.

## Github Flow 

- main : 언제든 배포가 가능한 상태를 유지해야 한다. main으로 merge하기 전에는 엄격한 테스트를 거쳐야 한다. (CI 필수)
- 나머지 브랜치 : main에서 생성하며 이름, 규칙 등 자유롭게 결정한다. 이때, 브랜치 명과 커밋 메시지는 어떤 일을 하고 있는지 자세하게 작성해야 한다.

## Experience 

### 문제 

#### 기능이 반영되는데 까지 걸리는 시간과 복잡성
- 여러 종류의 branch 로 인한 복잡성 및 작은 기능이 prod 혹은 stage 환경에 반영되는데 까지 오랜시간이 걸린다. 
- hotfix 혹은 release 에서 변경될 경우 듀얼 머지를 해야하기 때문에 번거로울뿐더러 실수 유발 가능성이 높다.
- 브랜치 사이에서 의존성이 증가하고 코드 충돌 발생.

> 대규모 프로젝트가 아닌, 기능 추가가 잦은 상황에서 Git Flow 가 최선일까에 대한 의문이 들었다.

### 해결

#### Trunk Based Development
- 트렁크 기반 개발에서는 main(또는 trunk)이라는 주 브랜치 하나만 운영합니다. 
- 신규 피쳐는 main에 바로 커밋하거나, 며칠 내로 main에 머지할 피쳐 브랜치에서 작업합니다.

- 브랜치 관리에 드는 리소스가 대폭 절약됩니다. 개발자가 각자 자신이 맡은 피쳐 브랜치를 main 브랜치와 싱크를 맞추는 것만으로도 충분합니다.
- 며칠 단위로 main에 머지하기 때문에, 머지 시 발생하는 변경이 작아집니다. 따라서 컨플릭트는 보통 작거나 없고, 코드 리뷰도 용이합니다.
- 배포하기 위해서는 main에 머지하는 것만으로 충분합니다. 배포 프로세스가 간단해져서, 더욱 자주 배포할 수 있게 됩니다.

#### Trunk Based Development 문제 

- main 브랜치의 모든 커밋이 배포 가능한 상태를 보장하지 못하는 문제가 발생. 
- QA 중인 기능이 main 브랜치에 반영되어있고 hotfix 가 만약 발생하게 될 경우 배포프로세스가 굉장히 복잡해진다. 

#### Feature Flag
- 환경 별 분기처리를 통해, main 브랜치의 모든 커밋이 배포 가능한 상태를 보장할 수 있도록 한다.