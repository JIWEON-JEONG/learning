# RPC

## 배경 
음성이나 채팅 시스템 같은 경우 HTTP 통신으로 구현에는 다음과 같은 한계가 있어, 소켓프로그래밍 과 같은 네트워크 프로그래밍을 통해 구현을 하였다.
- Header, 메타데이터의 크기로 인한 통신 리소스 낭비.
- JSON, XML 데이터 형식의 데이터 크기 및 파싱 속도로 인한 오버헤드.

하지만 소켓을 직접 구현함에 있어서 복잡한 구현 과정을 거쳐야했다.

- 프로토콜 설계: 통신 규칙, 메시지 형식, 데이터 포맷 등을 직접 정의.
- 저수준 통신처리 : TCP 연결 설정, 바이트 스트림 직렬화/역직렬화, 오류 처리 등을 모두 직접 코드로 구현.

RPC 는 이러한 복잡성을 추상화하여, 개발자가 마치 로컬 함수를 호출하듯 원격 함수를 사용할 수 있게 해준다.

## 해결 
- 서버와 클라이언트가 공유할 인터페이스를 정의한다. 
- 인터페이스를 기반으로 Stub 이라는 프록시 코드를 자동 생성한다.
- 저수준 통신처리 등 복잡한 로직들을 내부적으로 처리해주고, 사용자는 정의된 인터페이스의 구현체 (Stub)을 사용.


## 동작방식 
1. 스텁(Stub) 생성: 클라이언트와 서버는 서로 통신할 함수에 대한 인터페이스를 정의하고, 이를 기반으로 스텁이라는 프록시 코드를 생성.

2. 클라이언트 호출: 클라이언트는 로컬에 있는 스텁 함수를 호출합니다.

3. 마샬링(Marshaling): 클라이언트 스텁은 함수 호출에 필요한 매개변수들을 네트워크를 통해 전송 가능한 형태로 변환(직렬화).

4. 전송: 변환된 데이터를 서버로 전송.

5. 언마샬링(Unmarshalling): 서버 스텁은 전송된 데이터를 원래의 형태로 복원(역직렬화).

6. 서버 함수 실행: 서버는 복원된 매개변수로 실제 원격 함수를 실행.

7. 응답: 서버는 결과를 다시 직렬화하여 클라이언트로 전송. 클라이언트 스텁은 이를 역직렬화하여 최종 결과를 클라이언트에 전달.

# Grpc

## 배경 
기존의 rpc 프레임워크들은 아래와 같은 한계점이 존재하였다. 

- 플랫폼 종속성 : 다양한 기술스택을 사용하는 환경에서 호환성 문제.
- HTTP 1.1 : 멀티플렉싱이나 양방향 스트리밍을 지원하지 않아 실시간 통신 구현에 문제가 있었다.

## 해결

- ProtocolBuffer 를 통해 데이터 전송 효율을 높이고, 데이터 타입 안정화.
- HTTP/2 를 기반으로, 멀티플렉싱 및 헤더 압축을 통해 데이터 통신 효율 높였다.
- ProtocolBuffer 를 통해 언어 독립성 확보.

### ProtocolBuffer

- 직렬화 데이터 구조이다. 
- .proto 파일에 데이터 구조 정의.
- 바이너리 형식(0,1)으로 직렬화 하여 구문분석, 데이터타입 추론, 변환 등의 작업이 생략되어, 데이터 전송 효율 극대화.
- protoc 컴파일러를 통해서 원하는 언어의 코드로 변환 할 수 있다.



## 동작방식 

1. 인터페이스 정의 (.proto 파일): 클라이언트와 서버가 공유할 서비스의 인터페이스를 .proto 파일에 정의합니다. 이 파일은 함수 이름, 매개변수, 반환 값 등을 명확하게 명시하는 스키마(Schema) 역할을 합니다.

2. 스텁 코드 자동 생성: .proto 파일을 컴파일하면 다양한 언어(C++, Java, Python, Go 등)로 작성된 스텁(Stub) 코드가 자동으로 생성됩니다. 이 코드는 클라이언트와 서버가 실제로 통신하는 데 필요한 로직을 담고 있습니다.

3. 클라이언트 호출: 클라이언트는 자동 생성된 스텁을 통해 서버의 함수를 호출합니다.

4. Protocol Buffers 직렬화: 클라이언트 스텁은 함수 호출에 필요한 데이터를 Protocol Buffers를 사용하여 효율적인 바이너리 형식으로 직렬화합니다.

5. HTTP/2 전송: 직렬화된 데이터는 HTTP/2 프로토콜을 통해 서버로 전송됩니다. 이 과정에서 HTTP/2의 멀티플렉싱 덕분에 하나의 연결로 여러 요청을 동시에 처리할 수 있습니다.

6. 역직렬화 및 함수 실행: 서버는 전달받은 데이터를 Protocol Buffers를 통해 다시 원래의 형태로 복원(역직렬화)하고, 실제 서버의 함수를 실행합니다.

7. 응답: 실행 결과는 다시 Protocol Buffers로 직렬화되어 HTTP/2를 통해 클라이언트로 전송됩니다. 클라이언트는 이 데이터를 역직렬화하여 최종 결과를 받습니다.


## Proto 파일 설계 전략 
1. Enum 정의 시 0 번은 UNSPECIFIED 로 정의하자.

> proto3 에서는 기본 필드들이 optional field 이고, enum 을 0번 부터 정의하게 될 경우 
> 데이터가 null 로 들어왔음에도 불구하고 default value 인 0번의 value 값으로 덮어쓰의게 된다. 
> 이는 데이터 무결성을 헤칠 수 있으므로, 이런부분을 조심하자.


2. 없어지는 필드는 reserved 키워드를 통해 해결.

> 필드 번호 재사용 방지 및 하위호환성을 위해.



