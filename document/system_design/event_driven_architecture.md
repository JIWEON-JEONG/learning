# Event Driven Architecture

## 배경 
여러 서버들이 상호작용하는 환경에서, 동기적 통신은 아래와 같은 문제점이 존재한다. 

1. 강한 결합 
2. 장애 전파 
3. 낮은 확장성 (각 서버의 코드 모두 수정 및 배포 필요)

## 해결 
EDA 는 이러한 문제를 이벤트라는 비동기 통신을 통해 강한 결합을 느슨하게 하고, 시스템의 확장성과 유연성을 높인다. 


## 중요하게 다뤄야 할 Point 
- 이벤트 트래킹 및 모니터링 
- 멱등성
- 순서보장 
- 실패처리 및 복구 메커니즘 

## 이벤트 트래킹 및 모니터링 

### Transaction Outbox Pattern 

#### 배경
분산 트랜잭션 문제를 해결하기 위해 나오게 된 Pattern 이다. 

> 1. 서비스 A가 데이터베이스에 데이터 변경 (Update Database)  
> 2. 서비스 A가 메시지 브로커에 메시지 전송 (Publish Message)

위와 같은 시나리오가 존재할 때, 

*1번을 수행한 후 서버가 다운되거나 네트워크 이슈로 2번을 수행하지 못할 경우*  이벤트가 유실 될 수 있다. 
이러한 문제를 인식하여도, 후처리에 대한 작업에 대한 이슈가 존재한다. 

Transaction Outbox Pattern 은 데이터 변경과 이벤트저장을 하나의 트랜잭션으로 묶어, 이벤트 유실을 방지하고 실패 시 복구를 용이하도록 한다. 

#### 배경에 대한 경험 
매칭 시스템에서, 유저 원장 데이터와 매칭에 필요한 유저에 대한 데이터를 모아둔 유저 풀을 관리한다고 가정한다.  
유저의 원장데이터가 변경될 경우 이벤트를 통해 유저 풀에 대한 데이터를 Sync 해주는 상황을 예로 들어본다.  

> CS 를 통해 유저 풀과의 Sync 가 제대로 되지 않았다.

이러한 이슈를 받게 되었을 때, 이슈 트래킹을 하는게 쉽지 않았다. 

- 원장 유저 데이터는 정상적으로 수정 되었는가 
- 이벤트가 정상적으로 발행 되었는가 
- 유저풀을 업데이트 과정은 정상적으로 이루어졌는가

이러한 정보들을 로그 혹은 Kafka 메세지 히스토리를 보면서 트래킹을 해야했다.

또한 이슈에 대한 원인을 파악해도, 복구 하는데에 리소스가 많이 들었다. 
- 수동복구 
- 서버 (개발자) 마다 다른 복구 메커니즘 

복구에 대한 부분은 아래에서 살펴보기로 하고, Transaction Outbox Pattern 을 통해 로그 와 히스토리를 모두 찾아볼 필요없이 
문제가 발생했을때 어느정도 어떤 문제인지 빠르게 파악할 수 있도록, 애초에 그러한 문제가 발생하지 않도록 하는 것을 목표로 도입하게 되었다. 

#### 해결 

데이터의 수정과 발행하는 이벤트의 영속화를 하나의 트랜잭션으로 묶는다.  
이를 통해 데이터의 수정 후 이벤트 유실로 인한 데이터 무결성 문제를 해결할 수 있다. 

이벤트의 정상 발행 같은 경우, 영속화 된 이벤트에 대한 정보를 기반으로 만일 실패시에도 재시도 정책이나 즉각적인 알림을 통해서 
어떤 문제인지 빠르게 파악 할 수 있고, 이는 빠르게 대응할 수 있게 한다.
정상 발행 시, outbox row 에 정상 발행되었다는 상태를 업데이트 쳐준다.

## 순서보장
- Kafka 를 통해 명확한 순서보장이 필요한 경우, 파티션 지정을 통해 순서를 보장할 수 있다.

## 실패처리 및 복구 메커니즘

### 문제 

- 컨슈머 측에서의 실패 
- 실패 시 복구 메커니즘 

### 해결 
- 컨슈머 측에서의 실패는 DLQ 를 통해 관리하고, 복구 메커니즘에 이용한다. 
- DLQ 를 발행할때, 서비스 Name 과 Retry 수를 함께 발행하여, 잘못된 메시지로 인한 오버헤드를 줄일 수 있다. 

